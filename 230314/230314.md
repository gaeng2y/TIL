## Continuation

> `struct CheckedContinuation<T, E> where E : [Error](https://developer.apple.com/documentation/swift/error)`
A mechanism to interface between synchronous and asynchronous code, logging correctness violations.
> 

AÂ *continuation*Â is an opaque representation of program state. To create a continuation in asynchronous code, call theÂ `withUnsafeContinuation(function:_:)`Â orÂ `withUnsafeThrowingContinuation(function:_:)`Â function. To resume the asynchronous task, call theÂ `resume(returning:)`,Â `resume(throwing:)`,Â `resume(with:)`, orÂ `resume()`Â method.

<aside>
ğŸ’¡ **Important**

You must call a resume method exactly once on every execution path throughout the program.

</aside>

## AsyncSequence / AsyncStream

### AsyncSequence

> `@rethrows protocol AsyncSequence`
A type that provides asynchronous, sequential, iterated access to its elements.
> 

AnÂ `AsyncSequence`Â resembles theÂ `Sequence`Â type â€” offering a list of values you can step through one at a time â€” and adds asynchronicity. AnÂ `AsyncSequence`Â may have all, some, or none of its values available when you first use it. Instead, you useÂ `await`Â to receive values as they become available.

### AsyncStream

> `struct AsyncStream<Element>`
An asynchronous sequence generated from a closure that calls a continuation to produce new elements.
> 

`AsyncStream`Â conforms toÂ `AsyncSequence`, providing a convenient way to create an asynchronous sequence without manually implementing an asynchronous iterator. In particular, an asynchronous stream is well-suited to adapt callback- or delegation-based APIs to participate withÂ `async`-`await`.

### for-await

```swift
for await i in Counter(howHigh: 10) {
    print(i, terminator: " ")
}
// Prints "1 2 3 4 5 6 7 8 9 10"

let found = await Counter(howHigh: 10).contains(5) // true

let stream = Counter(howHigh: 10)
    .map { $0 % 2 == 0 ? "Even" : "Odd" }
for await s in stream {
    print(s, terminator: " ")
}
// Prints "Odd Even Odd Even Odd Even Odd Even Odd Even"
```

## Actor

> Common protocol to which all actors conform.
> 

`@Sendable`ì¸ ê³µìœ  ìì›ì„ ì†Œì§€í•œ íƒ€ì…

actorë§ˆë‹¤  ë…ë¦½ëœ(ioslated) ì‘ì—… íë¦„ì„ ê°€ì§„ë‹¤

![wwdc2022-110350_hd.mp4 - 02.03.123.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/845d7739-b275-48c9-83d1-535e1426d23b/wwdc2022-110350_hd.mp4_-_02.03.123.png)

```swift
class Counter {
    var count: Int = 0
    
    func increment() {
        self.count += 1  // data racing!!
    }
}

let counter = Counter()
// global
DispatchQueue.global().async {
     counter.increment()
}
// main
counter.increment()
```

actor : prevent shared mutable state

```swift
actor Counter {
		// isolated
    var count: Int = 0
    
    func increment() {
        self.count += 1
    }
}

func someFunction() async {
		let counter = Counter()
		await counter.increment()
}
```

### Main Actor

> A singleton actor whose executor is equivalent to the main dispatch queue.
> 

ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ì„ ë³´ì¥í•˜ëŠ” actor

`@MainActor` attributeëŠ” íƒ€ì…, ë©”ì„œë“œ ë“±ì— ë¶™ì—¬ì¤„ ìˆ˜ ìˆë‹¤

## Sendable

> A type whose values can safely be passed across concurrency domains by copying.
> 

`@Sendable`

You can safely pass values of a sendable type from one concurrency domain to another â€” for example, you can pass a sendable value as the argument when calling an actorâ€™s methods. All of the following can be marked as sendable:

- Value types
- Reference types with no mutable storage
- Reference types that internally manage access to their state
- Functions and closures (by marking them withÂ `@Sendable`)

Although this protocol doesnâ€™t have any required methods or properties, it does have semantic requirements that are enforced at compile time. These requirements are listed in the sections below. Conformance toÂ `Sendable`Â must be declared in the same file as the typeâ€™s declaration.

## Concurrency / Combine

- Concurrency : `Perform asynchronous and parallel operations.`
    - ë¹„ë™ê¸°, ë³‘ë ¬ ì‘ì—…ì„ ìœ„í•œ ì–¸ì–´ ê¸°ëŠ¥
- Combine : `Customize handling of asynchronous events by combining event-processing operators.`
    - ì´ë²¤íŠ¸ ë“±ìœ¼ë¡œ ë³€ê²½ë˜ëŠ” ê°’ì˜ ë³€í™”ì— ëŒ€ì‘í•˜ê¸° ìœ„í•œ í”„ë ˆì„ì›Œí¬